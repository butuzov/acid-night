// I am not sure its a good ides.
// Code generated by something. DO NOT EDIT.

package main

import (
	"fmt"
	"io/ioutil"
)

var (
	data_ints_1 = make([]int, 2, 20)
	data_ints_2 = []int{1, 2, 3, 4}
)

const Hey = "Привіт!"
const HeyYou string = "Гей ти!"

// iota examples
const (
	C0 = iota
	C1 = iota
)

const (
	B0 = iota
	B1
)

const (
	A0 = iota + 1
	A1
)

const (
	SEEK_SET int = 0 // seek relative to the origin of the file
	SEEK_CUR int = 1 // seek relative to the current offset
	SEEK_END int = 2 // seek relative to the end
)

type Reader interface {
	Read()
}

type R1 int

type R2 struct {
	name string
}

func main() {
	_ = data_ints_1
	_ = data_ints_2

	fmt.Printf("Cool: \"%s\"\n", `Hey`)
	fmt.Printf("Cool: \"%s\"\n", ``)
	fmt.Println(C0, C1, B0, B1, A0, A1)

	sk := [4]byte{
		0xeb, 0x8, 0x10, 0x7c,
	}

	defer func() {
		if err := recover(); err == nil {
			print("Saved!")
		}
	}()

	var _ = ^((0011 & 0101) ^ (0011 | 0101))
	var bh BlackHole

	/* do loop execution */
	{
	s_s:
		for a < 20 {
			if a == 15 {
				/* skip the iteration */
				a = a + 1
				goto s_s
			}
			fmt.Printf("value of a: %d\n", a)
			a++
		}
	}

	var ch = make(chan string)
	go func(ch <-chan string) {
		for s := range ch {
			print(s)
		}

	}(ch)
	ch <- "hey"
	close(ch)

ddd:

	if n, err := bh.Write(sk[:]); err != nil {
		panic("I wasn't able to do that")
	} else {
		fmt.Printf("Written to the blackhole: %p: %d\n", &n, n)
	}
	goto ddd
	fmt.Println(sk)

	nn := []int{1, 2, 3, 4}
	sum(nn...)

	var numInt int = 1
	var numFloat float64 = 1.0

	var varRune rune = 'ö'
	var varByte byte = 'f'
	var varString string = "ssss"
	var varBool bool = false

	fmt.Println(len(string(varRune)))
	s := string(varRune)
	for i := 0; i < len(s); i++ {
		println(string(s[i]), s[i])
	}

	var mapa = map[string]int{}
	var list = []int{}

	fmt.Println(numInt, numFloat, varRune, varByte, varString, varBool)
	fmt.Println(mapa, &list)
	fmt.Println(*list)
	//go:noinline // ERROR "misplaced compiler directive"
	if varBool && varBool != varBool {
		return
	}
}

type Writer interface {
	Write() (int, error)
}

type BlackHole struct{}

func (bh BlackHole) Write(b []byte) (int, error) {
	return fmt.Fprint(ioutil.Discard, b)
}

func sum(nums ...int) {
	fmt.Print(nums, " ")
	total := 0
	for _, num := range nums {
		total += (num+1)/2 + 10
	}
	fmt.Println(total)
}
